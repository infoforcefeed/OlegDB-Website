<!DOCTYPE html>
<!--
  ____ ____  _____ ____  _   _ _   _ _   _ _  _______ _
 / ___|  _ \| ____/ ___|| | | | | | | \ | | |/ / ____| |
| |  _| |_) |  _| \___ \| |_| | | | |  \| | ' /|  _| | |
| |_| |  _ <| |___ ___) |  _  | |_| | |\  | . \| |___| |___
 \____|_| \_\_____|____/|_| |_|\___/|_| \_|_|\_\_____|_____|

Proudly generated with GRESHUNKEL, a static site generator for the dead inside.
-->
<html>
    <head>
        <title>OlegDB -     Documentation

</title>
        <meta charset="UTF-8">
        <meta name=viewport content="width=device-width, initial-scale=1">
        
        <link href='https://fonts.googleapis.com/css?family=Lato' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" media="all" href="/static/css/simplegrid.css" />
        <link rel="stylesheet" media="all" href="/static/css/main.css" />
        <link rel="stylesheet" href="/static/css/documentation.css" />
<link rel="stylesheet" href="/static/css/prism.css"/>


        <link rel="stylesheet" media="(max-width: 800px)" href="/static/css/mobile.css" />
    </head>
    <body>
        <header>
            <div class="grid grid-pad">
                <div id="logo_col" class="col-1-12">
                    <div class="content">
                        <img src="/static/img/olegdb_logo_compact.svg">
                    </div>
                </div>
                <div id="olegdb_base_link" class="col-4-12">
                    <div class="content mobile_hide">
                        <h1><a href="/">OlegDB</a></h1>
                    </div>
                </div>
                <div id="right_side_nav" class="col-6-12">
                    <div class="pull-right content">
                        <ul>
                            <li class="mobile_show"><b><a href="/">OlegDB</a></b>
                            <li><a href="/blog.html">Blog</a></li>
                            <li><a href="/downloads.html">Downloads</a></li>
                            <li><a href="/faq.html">FAQ</a></li>
<li><a href="/docs/0.1.6/en/documentation.html">Docs</a></li>                            <li><a href="/community.html">Community</a></li>
                            <li><a id="git_icon" href="https://github.com/infoforcefeed/OlegDB"></a></li>
                        </ul>
                    </div> <!-- Content -->
                </div> <!-- right_side_nav -->
            </div> <!-- Grid -->
        </header>
        <div id="main_container">
                <div class="grid grid-pad">
        <div class="col-3-12">
            <div class="content">
                <p>Please send comments, corrections and angry letters to <a href="mailto:shithouse@goatse.cx">Quinlan Pfiffer.</a></p>
                <h1>OlegDB</h1>
                <ul>
<li><a href="#technical_internals">Technical Internals</a><ul><li><a href="#hash_table">Hash Table</a></li><li><a href="#splay_trees">Splay Trees</a></li><li><a href="#lz4_compression">LZ4 Compression</a></li><li><a href="#aol_file">AOL File</a></li><li><a href="#values_file">Values File</a></li></ul></li><li><a href="#overview">Overview</a><ul><li><a href="#what_is_olegdb">What is OlegDB</a></li><li><a href="#installation">Installation</a></li><li><a href="#getting_started">Getting Started</a></li><li><a href="#cursor_iteration">Cursor Iteration</a></li><li><a href="#prefix_matching">Prefix Matching</a></li><li><a href="#meta_operations">Meta Operations</a></li><li><a href="#bulk_unjar">Bulk Unjar</a></li></ul></li>                </ul>
                <h1>liboleg</h1>
                <ul>
                    <li>
                        <a href="#macros">Macros</a>
                        <ul>
<li><a href="#VERSION">VERSION</a></li><li><a href="#KEY_SIZE">KEY_SIZE</a></li><li><a href="#HASH_MALLOC">HASH_MALLOC</a></li><li><a href="#PATH_LENGTH">PATH_LENGTH</a></li><li><a href="#DB_NAME_SIZE">DB_NAME_SIZE</a></li><li><a href="#DEVILS_SEED">DEVILS_SEED</a></li><li><a href="#VALUES_FILENAME">VALUES_FILENAME</a></li><li><a href="#VALUES_DEFAULT_SIZE">VALUES_DEFAULT_SIZE</a></li><li><a href="#AOL_FILENAME_ALLOC">AOL_FILENAME_ALLOC</a></li><li><a href="#AOL_FILENAME">AOL_FILENAME</a></li><li><a href="#OL_SUCCESS">OL_SUCCESS</a></li>                        </ul>
                    </li>
                    <li>
                        <a href="#typedefs">Type Definitions</a>
                        <ul>
<li><a href="#ol_key_array">ol_key_array</a></li>                        </ul>
                    </li>
                    <li>
                        <a href="#enums">Enums</a>
                        <ul>
<li><a href="#ol_feature_flags">ol_feature_flags</a></li><li><a href="#ol_error">ol_error</a></li><li><a href="#ol_state_flags">ol_state_flags</a></li>                        </ul>
                    </li>
                    <li>
                        <a href="#structures">Structures</a>
                        <ul>
<li><a href="#ol_bucket">ol_bucket</a></li><li><a href="#ol_meta">ol_meta</a></li><li><a href="#ol_database">ol_database</a></li>                        </ul>
                    </li>
                    <li>
                        <a href="#functions">Functions</a>
                        <ul>
<li><a href="#ol_open">ol_open</a></li><li><a href="#ol_close">ol_close</a></li><li><a href="#ol_close_fast">ol_close_fast</a></li><li><a href="#ol_unjar">ol_unjar</a></li><li><a href="#ol_jar">ol_jar</a></li><li><a href="#ol_sniff">ol_sniff</a></li><li><a href="#ol_scoop">ol_scoop</a></li><li><a href="#ol_uptime">ol_uptime</a></li><li><a href="#ol_spoil">ol_spoil</a></li><li><a href="#ol_ht_bucket_max">ol_ht_bucket_max</a></li><li><a href="#ol_prefix_match">ol_prefix_match</a></li><li><a href="#ol_key_dump">ol_key_dump</a></li><li><a href="#ol_exists">ol_exists</a></li><li><a href="#ol_get_bucket">ol_get_bucket</a></li><li><a href="#ol_squish">ol_squish</a></li><li><a href="#ol_cas">ol_cas</a></li><li><a href="#ol_bulk_unjar">ol_bulk_unjar</a></li><li><a href="#ol_last_error">ol_last_error</a></li>                        </ul>
                    </li>
                </ul>
            </div>
        </div>
        <div class="col-9-12">
            <div class="content">
                <ul id="olegdb_versions">
<li><a href="/docs/0.1.0/en/documentation.html">0.1.0/</a></li><li><a href="/docs/0.1.1/en/documentation.html">0.1.1/</a></li><li><a href="/docs/0.1.2/en/documentation.html">0.1.2/</a></li><li><a href="/docs/0.1.3/en/documentation.html">0.1.3/</a></li><li><a href="/docs/0.1.4/en/documentation.html">0.1.4/</a></li><li><a href="/docs/0.1.5/en/documentation.html">0.1.5/</a></li><li><a href="/docs/0.1.6/en/documentation.html">0.1.6/</a></li>                </ul>
            </div>
<div class="doc_chunk"><h2 class="perma" id="technical_internals">Technical Internals <a href="#technical_internals">&para;</a></h2><h2 class="perma" id="hash_table">Hash Table <a href="#hash_table">&para;</a></h2><p>At it's core, OlegDB is just a hashtable. On a good day, this means operations
are <code>O(1)</code>. Since we use linked lists to handle collisions <a href=http://en.wikipedia.org/wiki/Hash_table#Separate_chaining_with_linked_lists>see here</a> 
the worst-case scenario for operations is <code>O(n)</code>. This usually doesn't happen.</p><p>Rehashing happens when we run out of space. To handle this, we currently
allocate a new block of memory, rehash all keys and move everything over. This
is a blocking operation. If you know you're going to have a lot of keys and want
to avoid this, you can tweak the <a href=#HASH_MALLOC>HASH_MALLOC</a> parameter before compilation.
This controls the default amount of space that OlegDB will allocate.</p><p></p><h2 class="perma" id="splay_trees">Splay Trees <a href="#splay_trees">&para;</a></h2><p>In addition to the hash table, OlegDB also keeps track of currently inserted
nodes via a <a href=https://en.wikipedia.org/wiki/Splay_tree>splay tree.</a> Going over
the intricacies of splay trees is a little outside the scope of this
documentation, but we do use it for several things and for several reasons.</p><p>In their simplified form, splay trees are just a specialized form of a
<a href=https://en.wikipedia.org/wiki/Binary_search_tree>self-balancing binary search tree.</a> 
This means that searching for any given key in the tree is an <code>O(log n)</code>
operation and can be done relatively quickly.</p><p>In addition to be a binary tree, a splay tree has the property of moving
recently inserted keys to the top of the tree. This is known as a <a href=https://en.wikipedia.org/wiki/Splay_tree#Splaying>splaying
operation</a>. While some splay
tree implementations splay on read, write and deletion, OlegDB only splays keys
to the top of the tree upon insertion and deletion. We figured that, since the
splay tree is at most a secondary structure in the Oleg ecosystem, we wanted
it's impact to be minimal.</p><p>With splay trees installed, we can now iterate through the tree in a timely and
efficient manor, and whats more, in a user-decided order.</p><p>Binary trees have <a href=https://en.wikipedia.org/wiki/In-order_traversal>several modes of traversal</a>
that can be useful in a database context. Traversing the tree in-order gives the
user the ability to retrieve keys alphabetically, while traversing in a
pre-ordered fashion will show the user when the keys were inserted.</p><p>Besides key-traversal, splay trees are used for <a href=#ol_prefix_match>prefix matching</a>. 
Since binary trees are inherently sorted, we can iterate through one much faster
than we could a list.</p><p>Splay trees can be turned on/off by changing how you open a database. See
<a href=#ol_feature_flags>ol_feature_flags</a> for a complete list of toggleable
parameters.</p><p></p><h2 class="perma" id="lz4_compression">LZ4 Compression <a href="#lz4_compression">&para;</a></h2><p>OlegDB uses the super-fast <a href=https://code.google.com/p/lz4/>LZ4 compression algorithm</a>
for keeping values on disk in a smaller size while maintaining a low-impact on
insertion/deletion.</p><p>This is a toggleable feature. See <a href=#ol_feature_flags>ol_feature_flags</a> for more
detail.</p><p></p><h2 class="perma" id="aol_file">AOL File <a href="#aol_file">&para;</a></h2><p>The <strong>A</strong>ppend <strong>O</strong>nly <strong>L</strong>og file is how Oleg keeps track of state outside of
it's values files. Everytime a change occurs to OlegDB, that command is written
to the AOL file. This is what allows OlegDB to be persistent.</p><p>Every now and then the AOL file needs to be <a href=#ol_squish>squished (compacted)</a>
to remove old and expired data. The AOL file is designed to be human readable
(mostly) so you can tell at a glance whats going on with your database.</p><p></p><h2 class="perma" id="values_file">Values File <a href="#values_file">&para;</a></h2><p>The values file augments the <a href=#AOL_file>AOL file</a> in persisting state to the
disk. The values file is basically all of your data, more or less aligned in
<a href=#VALUES_DEFAULT_SIZE>four megabyte blocks</a>.</p><p>Starting in <code>0.1.2</code>, this is how we store data on disk. Previously all values
were stored in the AOL file. Instead, the values file is <code>mmap()</code>'d into RAM
on database startup, allowing you to hold datasets bigger than memory.</p><p></p></div><div class="doc_chunk"><h2 class="perma" id="overview">Overview <a href="#overview">&para;</a></h2><h2 class="perma" id="what_is_olegdb">What is OlegDB <a href="#what_is_olegdb">&para;</a></h2><p>OlegDB is a concurrent, pretty fast K/V hashtable with an Go frontend.
It uses the Murmur3 hashing algorithm to hash and index keys. We chose
Go for the server because it is easy to rapidly create an HTTP frontend that is
performant and has all the tools in core to prevent race conditions.</p><p>In addition to this, <code>liboleg</code> is the C library that powers everything. <code>liboleg</code> exports
a relatively simple API for use in other applications. We build the main
database off of this library.</p><p></p><h2 class="perma" id="installation">Installation <a href="#installation">&para;</a></h2><p>Installing OlegDB is pretty simple, you only need a POSIX compliant system,
<code>make</code>, <code>gcc</code>/<code>clang</code> (thats all we test) and Go. You'll also need the source
code for OlegDB.</p><p>Once you have your fanciful medley of computer science tools, you're ready to
dive into a lengthy and complex process of program compilation. Sound
foreboding? Have no fear, people have been doing this for at least a quarter of
a century.</p><p>I'm going to assume you've extracted the source tarball into a folder called
<code>~/src/olegdb</code> and that you haven't <code>cd</code>'d into it yet. Lets smash some electrons
together:</p><p><pre class="language-bash
"><code>$ cd ~/src/olegdb
$ make
$ sudo make install
</code></pre></p><p>If you really wanted to, you could specify a different installation directory.
The default is <code>/usr/local</code>. You can do this by setting the <code>PREFIX</code> variable
before compilation:</p><p><pre class="language-bash
"><code>$ sudo make PREFIX=/usr/ install
</code></pre></p><p>Actually running OlegDB and getting it do stuff after this point is trivial, if
your installation prefix is in your <code>PATH</code> variable  you should just be able to run
something like the following:</p><p><pre class="language-bash
"><code>$ olegdb -config /path/to/json/config
</code></pre></p><p>OlegDB ships with a default configuration file, <code>olegdb.conf.sample</code> which will
get you up and running.</p><p></p><h2 class="perma" id="getting_started">Getting Started <a href="#getting_started">&para;</a></h2><p>Communicating with OlegDB is done via a pretty simple <code>REST</code> interface.
You <code>POST</code> to create/update records, <code>GET</code> to retrieve them, <code>DELETE</code> to delete,
and <code>HEAD</code> to get back some information about them. Probably.</p><p>For example, to store the value <code>Raphael</code> into the database named <code>turtles</code> under
the key <code>red</code> you could use something like the following:</p><p><pre class="language-
"><code>$ curl -X POST -d 'Raphael' http://localhost:8080/turtles/red
</code></pre></p><p>Retrieving data is just as simple:</p><p><pre class="language-
"><code>$ curl http://localhost:8080/turtles/red
</code></pre></p><p>Deleting keys can be done by using DELETE:</p><p><pre class="language-
"><code>$ curl -X DELETE http://localhost:8080/turtles/red
</code></pre></p><p>OlegDB supports lazy key expiration. You can specify an expiration date by setting the
<code>X-OlegDB-use-by</code> header to a *UTC* POSIX timestamp.</p><p><pre class="language-
"><code>$ curl -X POST \
-H "X-OlegDB-use-by: $(date +%s)" \
-d '{turtle: "Johnny", age: 34}' http://localhost:8080/turtles/Johnny
&gt; POST /turtles/Johnny HTTP/1.1
&gt; User-Agent: curl/7.22.0 (x86_64-pc-linux-gnu) libcurl/7.22.0
&gt; Host: localhost:8080
&gt; Accept: */*
&gt; X-OlegDB-use-by: 1394323192
&gt; Content-Type: application/octet-stream
&gt; Content-Length: 27
&gt;
\* upload completely sent off: 27out of 27 bytes
&lt; HTTP/1.1 200 OK
&lt; Server: OlegDB/fresh_cuts_n_jams
&lt; Content-Type: text/plain
&lt; Connection: close
&lt; Content-Length: 7
&lt;
無駄
</code></pre></p><p>And then when we try to get it back out again:</p><p><pre class="language-
"><code>$ curl -v http://localhost:8080/turtles/Johnny
&gt; GET /turtles/Johnny HTTP/1.1
&gt; User-Agent: curl/7.22.0 (x86_64-pc-linux-gnu) libcurl/7.22.0
&gt; Host: localhost:8080
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 404 Not Found
&lt; Status: 404 Not Found
&lt; Server: OlegDB/fresh_cuts_n_jams
&lt; Content-Length: 26
&lt; Connection: close
&lt; Content-Type: text/plain
&lt;
These aren't your ghosts.
</code></pre></p><p>As you can hopefully tell, the POST succeeds and a 200 OK is returned. We
used the bash command <code>date +%s</code> which returns a timestamp. Then, immediately
trying to access the key again results in a 404, because the key expired.</p><p>If you want to retrieve the expiration date of a key, you can do so by sending HEAD:</p><p><pre class="language-
"><code>$ curl -v -X HEAD http://localhost:8080/turtles/Johnny
&gt; HEAD /turtles/Johnny HTTP/1.1
&gt; User-Agent: curl/7.35.0
&gt; Host: localhost:8080
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 200 OK
\* Server OlegDB/fresh_cuts_n_jams is not blacklisted
&lt; Server: OlegDB/fresh_cuts_n_jams
&lt; Content-Length: 0
&lt; Content-Type: application/octet-stream
&lt; Expires: 1395368972
&lt;
</code></pre></p><p></p><h2 class="perma" id="cursor_iteration">Cursor Iteration <a href="#cursor_iteration">&para;</a></h2><p>In <code>0.1.2</code>, we added the ability to iterate through keys inserted into the
database via the frontend. It's a pretty simple interface and follows the rest
of the current URL idioms.</p><p>Each cursor operand is of the form <code>/database/key/operand</code>. In some
operands (<code>_last</code> and <code>_first</code>) the <code>key</code> option is the operand. Using them is
trivial.</p><p>Using any of the operands will return both the value of the key you requested
(<code>_next</code> will return the next value, <code>_prev</code> will return the previous value, etc.)
and the HTTP header <code>X-Olegdb-Key</code> followed by the key paired to the value you
just retrieved. For example, say we have two keys in the database, <code>aaa</code> and
<code>bbb</code>. To begin with, I can request the first key in the database:</p><p><pre class="language-
"><code>$ curl -i localhost:8080/oleg/_first
HTTP/1.1 200 OK
X-Olegdb-Key: aaa
Date: Sun, 28 Sep 2014 07:23:39 GMT
Content-Length: 21
Content-Type: text/plain; charset=utf-8</p><p>I am the value of aaa
</code></pre></p><p>As you can see, the key <code>aaa</code> is the first one in the tree of ordered keys. If
you're paying attention, you've also noticed that I've omitted the parameter
between the <code>database</code> specifier and the cursor operand <code>_first</code>. This is
because the <code>key</code> is not used in this command. It will, however, be used in
the next:</p><p><pre class="language-
"><code>$ curl -i localhost:8080/oleg/aaa/_next
HTTP/1.1 200 OK
X-Olegdb-Key: bbb
Date: Sun, 28 Sep 2014 07:24:16 GMT
Content-Length: 21
Content-Type: text/plain; charset=utf-8</p><p>I am the value of bbb
</code></pre></p><p>Logically, the key <code>bbb</code> follows the key <code>aaa</code>. Nice. In our request, we asked
Oleg for the key after (<code>_next</code>) the key <code>aaa</code>. The value of the next key was
returned, and we can see the header <code>X-OlegDB-Key</code> is set to the key that
corresponds to that value. Lets see what happens if we try to get the next key,
knowing that we only have two keys (<code>aaa</code> and <code>bbb</code>) in our database:</p><p><pre class="language-
"><code>$ curl -i localhost:8080/oleg/bbb/_next
HTTP/1.1 404 Not Found
Content-Type: text/plain; charset=utf-8
Date: Sun, 28 Sep 2014 07:24:26 GMT
Content-Length: 17</p><p>No records found
</code></pre></p><p>We get a 404 statuscode and a message to match. This informs us that we cannot
iterate any farther and that we have reached the end of the list.</p><p>In addition to these to commands, you can use <code>_last</code> to find the last key in
the database and <code>_prev</code> to iterate backwards. The usage of these commands is
identical to those above:</p><p><pre class="language-
"><code>$ curl -i localhost:8080/oleg/_last
HTTP/1.1 200 OK
X-Olegdb-Key: bbb
Date: Sun, 28 Sep 2014 07:24:50 GMT
Content-Length: 21
Content-Type: text/plain; charset=utf-8</p><p>I am the value of bbb</p><p>$ curl -i localhost:8080/oleg/bbb/_prev
HTTP/1.1 200 OK
X-Olegdb-Key: aaa
Date: Sun, 28 Sep 2014 07:25:06 GMT
Content-Length: 21
Content-Type: text/plain; charset=utf-8</p><p>I am the value of aaa</p><p>$ curl -i localhost:8080/oleg/aaa/_prev
HTTP/1.1 404 Not Found
Content-Type: text/plain; charset=utf-8
Date: Sun, 28 Sep 2014 07:25:17 GMT
Content-Length: 17</p><p>No records found
</code></pre></p><p></p><h2 class="perma" id="prefix_matching">Prefix Matching <a href="#prefix_matching">&para;</a></h2><p>In addition to <a href=#cursor_iteration>cursor iteration</a> <code>0.1.2</code> added the ability
to return the keys that match a given prefix. Use of this feature follows the
same URL layout as it's predeccesors, mainly via the use of the
<code>_match</code> qualifier.</p><p>For example, say I have three keys in the database, <code>test_a</code>, <code>test_b</code> and
<code>test_c</code>. I can easily find these keys in one operation by using the <code>_match</code>
operand. To demonstrate:</p><p><pre class="language-
"><code>$ curl -i localhost:8080/oleg/test/_match
HTTP/1.1 200 OK
Date: Sun, 28 Sep 2014 07:26:35 GMT
Content-Length: 20
Content-Type: text/plain; charset=utf-8</p><p>test_a
test_b
test_c
</code></pre></p><p>This returns a list of all the keys separated by <code>\n</code>. Also of note is the
<code>X-Olegdb-Num-Matches</code> header which specifies the number of keys that matched
the given prefix.</p><p>If no matches are present, a 404 is returned.</p><p>Similar to prefix matching, you can also just dump the entire keyspace using
'_all', keep in mind however that this can be an expensive operation.</p><p><pre class="language-
"><code>$ curl localhost:38080/waifu/_all | head
HTTP/1.1 200 OK
Content-Length: 27863
X-Olegdb-Num-Matches: 401
Date: Sun, 11 Jan 2015 21:26:08 GMT
Content-Type: text/plain; charset=utf-8</p><p>alias50B224D2C7987CE4F51E9258707758841771C82E9A0D3395C849426F6E93B8A85FE94AB42A00845C
alias70170858147E2B26DD5370D9F97113E0D7FDA993A707D5B0304272E93BA9A031372339E4C8F94AA2
alias70170858147E2B26DD5370D9F97113E0D7FDA993A707D5B0304272E93BA9A031383CEF2534DF870A
alias70170858147E2B26DD5370D9F97113E0D7FDA993A707D5B0304272E93BA9A031717594C273021004
...
</code></pre></p><p></p><h2 class="perma" id="meta_operations">Meta Operations <a href="#meta_operations">&para;</a></h2><p>OlegDB supports a handful of meta-operations. These operations are usually
prefixed with a single underscore, and do some additional work compared to the
usual get/set operations. At this point, if you've been following along, you've
already seen a handful including <code>_all</code>, <code>_match</code>, <code>_prev</code> and <code>_next</code>.
This document is intended to give you more detailed explanations for all of
the currently supported meta-operators that haven't been previously covered.
<h2><code>_info</code></h2></p><p><code>_info</code> spits out some additional meta data on a key that relates to the
database at large. As an example:</p><p><pre class="language-
"><code>$ curl -v localhost:38080/oleg/x/_info
&gt; GET /oleg/x/_info HTTP/1.1
&gt; User-Agent: curl/7.35.0
&gt; Host: localhost:38080
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 200 OK
&lt; Expires: 1423445413
&lt; X-Olegdb-Rcrd-Cnt: 1
&lt; Date: Sun, 08 Feb 2015 01:31:22 GMT
&lt; Content-Length: 2
&lt; Content-Type: text/plain; charset=utf-8</p><p></code></pre></p><p>So here you can see some useful information. We know that the <code>oleg</code> database
has exactly one record in it, and now we know that the key will expire whenever
1423445413 happens. The <code>X-OlegDB-Rcrd-Cnt</code> header tells us how many records
exist in this database.
<h2><code>_uptime</code></h2></p><p><code>_uptime</code> simply gives you the amount of time, in seconds, that a given database
has been up. So if we wanted to check the uptime of the previous example's
<code>oleg</code> database:</p><p><pre class="language-
"><code>$ curl -v localhost:38080/oleg/_uptime
&gt; GET /oleg/_uptime HTTP/1.1
&gt; User-Agent: curl/7.35.0
&gt; Host: localhost:38080
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 200 OK
&lt; Date: Sun, 08 Feb 2015 01:36:57 GMT
&lt; Content-Length: 3
&lt; Content-Type: text/plain; charset=utf-8
&lt;
482
</code></pre></p><p>It's been up 482 seconds.</p><p></p><h2 class="perma" id="bulk_unjar">Bulk Unjar <a href="#bulk_unjar">&para;</a></h2><p>Oleg supports a single bulk operation, which is a multi-key variant of the
<code>unjar</code> operation. Via the HTTP API, you POST a list of <code>\n</code> delimited values to
whatever database you want to retrieve values from, and you'll receieve the keys
back for your trouble.</p><p>Response format is a list of size, value pairs where the size is a zero-padded
64-bit integer representing the number of bytes following the size. So for
example if I had two values in the database <code>test</code>: <code>x</code> and <code>y</code>:</p><p><pre class="language-
"><code>$ curl -v -d 'x
z
y
y
y
y
' localhost:38080/test/_bulk_unjar
<ul><li>Connected to localhost (127.0.0.1) port 38080 (#0)</li></ul>
&gt; POST /test/_bulk_unjar HTTP/1.1
&gt; Host: localhost:38080
&gt; Content-Type: application/x-www-form-urlencoded
&gt; 
<ul><li>upload completely sent off: 12 out of 12 bytes</li></ul>
&lt; HTTP/1.1 200 OK
&lt; Date: Sun, 15 Mar 2015 17:30:40 GMT
&lt; Content-Length: 149
&lt; Content-Type: text/plain; charset=utf-8
&lt; 
<ul><li>Connection #0 to host localhost left intact</li></ul>
00000009THIS IS X0000000000000021THAT WAS X, THIS IS Y00000021THAT WAS X, THIS
IS Y00000021THAT WAS X, THIS IS Y00000021THAT WAS X, THIS IS Y00000000
</code></pre></p><p>So a couple of things happened here, first of all we requested multiple copies
of <code>y</code>. Thats fine.</p><p>Second, we request <code>z</code>, which is not a value in the database. This returned the
value <code>00000000</code> which fits the format, has no actual value and just keeps on
going to the next key.</p><p>Parsing is up to you, sky captain.</p><p>WARNING: This operation is unsafe for binary data. Current <code>unjar</code> will return a
null-terminated C string and no length in bytes. Since binary data can
potentially contain null characters, this means you should only _bulk_unjar keys
with values of ascii strings.</p><p></p></div>            <h1>liboleg</h1>

            <div class="language-c doc_chunk">
                <h2 class="perma" id="macros">Macros <a href="#macros">&para;</a></h2>
<h3 class="perma" id="VERSION">VERSION <a href="#VERSION">&para;</a></h3><pre><code>#define VERSION "0.1.6"
</code></pre><p>The current version of the OlegDB.</p><h3 class="perma" id="KEY_SIZE">KEY_SIZE <a href="#KEY_SIZE">&para;</a></h3><pre><code>#define KEY_SIZE 250
</code></pre><p>The hardcoded upperbound for key lengths.</p><h3 class="perma" id="HASH_MALLOC">HASH_MALLOC <a href="#HASH_MALLOC">&para;</a></h3><pre><code>#define HASH_MALLOC 65536
</code></pre><p>The size, in bytes, to allocate when initially creating the database. ol_bucket pointers are stored here.</p><h3 class="perma" id="PATH_LENGTH">PATH_LENGTH <a href="#PATH_LENGTH">&para;</a></h3><pre><code>#define PATH_LENGTH 256
</code></pre><p>The maximum length of a database's path.</p><h3 class="perma" id="DB_NAME_SIZE">DB_NAME_SIZE <a href="#DB_NAME_SIZE">&para;</a></h3><pre><code>#define DB_NAME_SIZE 64
</code></pre><p>Database maximum name length.</p><h3 class="perma" id="DEVILS_SEED">DEVILS_SEED <a href="#DEVILS_SEED">&para;</a></h3><pre><code>#define DEVILS_SEED 666
</code></pre><p>The seed to feed into the murmur3 algorithm.</p><h3 class="perma" id="VALUES_FILENAME">VALUES_FILENAME <a href="#VALUES_FILENAME">&para;</a></h3><pre><code>#define VALUES_FILENAME "val"
</code></pre><p>The file extension used for the values file on disk.</p><h3 class="perma" id="VALUES_DEFAULT_SIZE">VALUES_DEFAULT_SIZE <a href="#VALUES_DEFAULT_SIZE">&para;</a></h3><pre><code>#define VALUES_DEFAULT_SIZE 4194304
</code></pre><p>The default size of the values file on disk. 4 MB by default.</p><h3 class="perma" id="AOL_FILENAME_ALLOC">AOL_FILENAME_ALLOC <a href="#AOL_FILENAME_ALLOC">&para;</a></h3><pre><code>#define AOL_FILENAME_ALLOC 512
</code></pre><p>The number of bytes we allocate for the filename of the AOL file.</p><h3 class="perma" id="AOL_FILENAME">AOL_FILENAME <a href="#AOL_FILENAME">&para;</a></h3><pre><code>#define AOL_FILENAME "aol"
</code></pre><p>The file extension used for the AOL file.</p><h3 class="perma" id="OL_SUCCESS">OL_SUCCESS <a href="#OL_SUCCESS">&para;</a></h3><pre><code>#define OL_SUCCESS 0
</code></pre><p>Used to indicate an operation went according to plan.</p>            </div>
            <div class="language-c doc_chunk">
                <h2 class="perma" id="typedefs">Type Definitions <a href="#typedefs">&para;</a></h2>
<h3 class="perma" id="ol_key_array">ol_key_array <a href="#ol_key_array">&para;</a></h3><pre><code>typedef char **ol_key_array;
</code></pre><p>This is shorthand for a pointer to an array of keys, the same kind of key stored in an <a href="#ol_bucket">ol_bucket</a>'s <code>key[KEY_SIZE]</code>.</p>            </div>
            <div class="language-c doc_chunk">
                <h2 class="perma" id="enums">Enums <a href="#enums">&para;</a></h2>
<h3 class="perma" id="ol_feature_flags">ol_feature_flags <a href="#ol_feature_flags">&para;</a></h3><pre><code>typedef enum {
    OL_F_APPENDONLY                 = 1 << 0,
    OL_F_SPLAYTREE                  = 1 << 1,
    OL_F_LZ4                        = 1 << 2,
    OL_F_AOL_FFLUSH                 = 1 << 3,
    OL_F_DISABLE_TX                 = 1 << 4
} ol_feature_flags;
</code></pre><p>Feature flags tell the database what it should be doing.</p><p><span class="bold">OL_F_APPENDONLY:</span> Enable the append only log. This is a write-only logfile for simple persistence.</p><p><span class="bold">OL_F_SPLAYTREE:</span> Whether or not to enable to splay tree in the server. This can have a performance impact.</p><p><span class="bold">OL_F_LZ4:</span> Enable LZ4 compression.</p><p><span class="bold">OL_F_AOL_FFLUSH:</span> Make sure AOL data is REAAAALLY written to disk. This will run fflush after every AOL write. Otherwise, fsync only.</p><p><span class="bold">OL_F_DISABLE_TX:</span> Disable transactions on this database.</p><h3 class="perma" id="ol_error">ol_error <a href="#ol_error">&para;</a></h3><pre><code>typedef enum {
    OL_E_NO_ERROR       = 0,
    OL_E_GENERIC_ERROR  = 1
} ol_error;
</code></pre><p>Error codes.</p><p><span class="bold">OL_NO_ERROR:</span> Everything is fine.</p><p><span class="bold">OL_GENERIC_ERROR:</span> Unkown error of some kind. Like, whatever.</p><h3 class="perma" id="ol_state_flags">ol_state_flags <a href="#ol_state_flags">&para;</a></h3><pre><code>typedef enum {
    OL_S_STARTUP        = 0,
    OL_S_AOKAY          = 1,
    OL_S_COMMITTING     = 2
} ol_state_flags;
</code></pre><p>State flags tell the database what it should be doing.</p><p><span class="bold">OL_S_STARTUP:</span> Startup state. The DB is starting, duh.</p><p><span class="bold">OL_S_AOKAY:</span> The normal operating state, the database is a-okay</p><p><span class="bold">OL_S_COMMITTING:</span> The database is committing a transaction. It doesn't want to do anything else.</p>            </div>
            <div class="language-c doc_chunk">
                <h2 class="perma" id="structures">Structures <a href="#structures">&para;</a></h2>
<h3 class="perma" id="ol_bucket">ol_bucket <a href="#ol_bucket">&para;</a></h3><pre><code>typedef struct ol_bucket {
    char                *key;
    size_t              klen;
    size_t              data_offset;
    size_t              data_size;
    size_t              original_size;
    struct ol_bucket    *next; /* The next ol_bucket in this chain, if any */
    struct tm           *expiration;
    ol_splay_tree_node  *node;
    int                 tx_id;
} ol_bucket;
</code></pre><p>This is the object stored in the database's hashtable. Contains references to value, key, etc.</p><p><span class="bold">key[KEY_SIZE]:</span> The key used for this bucket.</p><p><span class="bold">klen:</span> Length of the key.</p><p><span class="bold">data_offset:</span> Location of this key's value (data) in the values file on disk.</p><p><span class="bold">data_size:</span> Length of the value (data) in bytes. This is the size of the data stored in memory.</p><p><span class="bold">original_size:</span> Length of the value (data) in bytes. This is the original length of the data we receieved, non-compressed.</p><p><span class="bold">next:</span> Collisions are resolved via linked list. This contains the pointer to the next object in the chain, or NULL.</p><p><span class="bold">expiration:</span> The POSIX timestamp when this key will expire.</p><p><span class="bold">*node:</span> A pointer to this objects node in the splay tree.</p><p><span class="bold">tx_id:</span> If this record is a part of a transaction, then this will be a non-negative integer.</p><h3 class="perma" id="ol_meta">ol_meta <a href="#ol_meta">&para;</a></h3><pre><code>typedef struct ol_meta {
    time_t     created;
    int        key_collisions;
    uint16_t   last_error;
} ol_meta;
</code></pre><p>Structure used to record meta-information about the database.</p><p><span class="bold">created:</span> When the database was created.</p><p><span class="bold">key_collisions:</span> The number of keys that have collided over the lifetime of this database.</p><h3 class="perma" id="ol_database">ol_database <a href="#ol_database">&para;</a></h3><pre><code>typedef struct ol_database {
    void            (*get_db_file_name)(const struct ol_database *db,const char *p,char*);
    void            (*enable)(int, int*);
    void            (*disable)(int, int*);
    bool            (*is_enabled)(const int, const int*);
    char            name[DB_NAME_SIZE];
    char            path[PATH_LENGTH];
    char            aol_file[AOL_FILENAME_ALLOC];
    FILE            *aolfd;
    int             feature_set;
    short int       state;
    int             rcrd_cnt;
    size_t          cur_ht_size;
    ol_bucket       **hashes;
    unsigned char   *values;
    int             valuesfd;
    size_t          val_size;
    ol_splay_tree   *tree;
    ol_splay_tree   *cur_transactions;
    ol_meta         *meta;
} ol_database;
</code></pre><p>The object representing a database. This is used in almost every ol_* function to store state and your data.</p><p><span class="bold">get_db_file_name:</span> A function pointer that returns the path to the location of the db file to reduce code duplication. Used for writing and reading of dump files.</p><p><span class="bold">enable:</span> Helper function to enable a feature for the database instance passed in. See <a href="#ol_feature_flags">ol_feature_flags</a></p><p><span class="bold">disable:</span> Helper function to disable a database feature. See <a href="#ol_feature_flags">ol_feature_flags</a></p><p><span class="bold">is_enabled:</span> Helper function that checks weather or not a feature flag is enabled.</p><p><span class="bold">name:</span> The name of the database.</p><p><span class="bold">path[PATH_LENGTH]:</span> Path to the database's working directory.</p><p><span class="bold">aol_file:</span> Path and filename of the append only log.</p><p><span class="bold">aolfd:</span> Pointer of FILE type to append only log.</p><p><span class="bold">feature_set:</span> Bitmask holding enabled/disabled status of various features. See ol_feature_flags.</p><p><span class="bold">state:</span> Current state of the database. See ol_state_flags.</p><p><span class="bold">rcrd_cnt:</span> Number of records in the database.</p><p><span class="bold">key_collisions:</span> Number of key collisions this database has had since initialization.</p><p><span class="bold">created:</span> Timestamp of when the database was initialized.</p><p><span class="bold">cur_ht_size:</span> The current amount, in bytes, of space allocated for storing <a href="#ol_bucket">ol_bucket</a> objects.</p><p><span class="bold">**hashes:</span> The actual hashtable. Stores <a href="#ol_bucket">ol_bucket</a> instances.</p><p><span class="bold">*values:</span> This is where values for hashes are stored. This is a pointer to an mmap()'d region of memory.</p><p><span class="bold">valuesfd:</span> The file descriptor of the values file.</p><p><span class="bold">val_size:</span> The size of the sum total of records in the db, in bytes. It is <strong>not</strong> the size of the file on disk.</p><p><span class="bold">*tree:</span> A pointer to the splay tree holding the ordered list of keys.</p><p><span class="bold">*cur_transactions:</span> The current open/uncommitted transactions. Represented with a splay tree.</p><p><span class="bold">*meta:</span> A pointer to a struct holding extra meta information. See <a href="#ol_meta">oleg_meta</a> for more information.</p>            </div>
            <div class="language-c doc_chunk">
                <h2 class="perma" id="functions">Functions <a href="#functions">&para;</a></h2>
<h3 class="perma" id="ol_open">ol_open <a href="#ol_open">&para;</a></h3><pre><code>ol_database *ol_open(const char *path, const char *name, int features);
</code></pre><p>Opens a database for use.</p><p><span class="bold">*path:</span> The directory where the database will be stored.</p><p><span class="bold">*name:</span> The name of the database. This is used to create the dumpfile, and keep track of the database.</p><p><span class="bold">features:</span> Features to enable when the database is initialized. You can logically OR multiple features together.</p><p><span class="bold">Returns:</span> A new database object. NULL on failure.</p><h3 class="perma" id="ol_close">ol_close <a href="#ol_close">&para;</a></h3><pre><code>int ol_close(ol_database *database);
</code></pre><p>Closes a database cleanly and frees memory.</p><p><span class="bold">*database:</span> The database to close.</p><p><span class="bold">Returns:</span> OL_SUCCESS on success, OL_FAILURE if not everything could be freed.</p><h3 class="perma" id="ol_close_fast">ol_close_fast <a href="#ol_close_fast">&para;</a></h3><pre><code>int ol_close_fast(ol_database *database);
</code></pre><p>Closes a database without syncing the AOL or Values file. Intended to be used for transaction that did nothing.</p><p><span class="bold">*database:</span> The database to close.</p><p><span class="bold">Returns:</span> OL_SUCCESS on success, OL_FAILURE if not everything could be freed.</p><h3 class="perma" id="ol_unjar">ol_unjar <a href="#ol_unjar">&para;</a></h3><pre><code>int ol_unjar(ol_database *db, const char *key, size_t klen, unsigned char **data, size_t *dsize);
</code></pre><p>This function retrieves a value from the database. <strong>data must be freed after calling this function!</strong> It also writes the size of the data to <code>dsize</code>. Pass dsize as NULL if you don't care.</p><p><span class="bold">*db:</span> Database to retrieve value from.</p><p><span class="bold">*key:</span> The key to use.</p><p><span class="bold">klen:</span> The length of the key to use.</p><p><span class="bold">data:</span> This parameter will be filled out with the data found in the DB. Passing NULL will check if a key exists.</p><p><span class="bold">*dsize:</span> Optional parameter that will be filled out with the size of the data, if NULL is not passed in.</p><p><span class="bold">Returns:</span> OL_SUCCESS on success, OL_FAILURE on failure or if the key was not found.</p><h3 class="perma" id="ol_jar">ol_jar <a href="#ol_jar">&para;</a></h3><pre><code>int ol_jar(ol_database *db, const char *key, size_t klen, const unsigned char *value, size_t vsize);
</code></pre><p>This is OlegDB's canonical 'set' function. Put a value into the mayo (the database). It's easy to piss in a bucket, it's not easy to piss in 19 jars.</p><p><span class="bold">*db:</span> Database to set the value to.</p><p><span class="bold">*key:</span> The key to use.</p><p><span class="bold">klen:</span> The length of the key.</p><p><span class="bold">*value:</span> The value to insert.</p><p><span class="bold">vsize:</span> The size of the value in bytes.</p><p><span class="bold">Returns:</span> OL_SUCCESS on success, OL_FAILURE on an obtuse set of different failure modes.</p><h3 class="perma" id="ol_sniff">ol_sniff <a href="#ol_sniff">&para;</a></h3><pre><code>struct tm *ol_sniff(ol_database *db, const char *key, size_t klen);
</code></pre><p>Retrieves the expiration time for a given key from the database.</p><p><span class="bold">*db:</span> Database to set the value to.</p><p><span class="bold">*key:</span> The key to use.</p><p><span class="bold">klen:</span> The length of the key.</p><p><span class="bold">Returns:</span> Stored <code>struct tm *</code> representing the time that this key will expire, or NULL if not found.</p><h3 class="perma" id="ol_scoop">ol_scoop <a href="#ol_scoop">&para;</a></h3><pre><code>int ol_scoop(ol_database *db, const char *key, size_t klen);
</code></pre><p>Removes an object from the database. Get that crap out of the mayo jar.</p><p><span class="bold">*db:</span> Database to remove the value from.</p><p><span class="bold">*key:</span> The key to use.</p><p><span class="bold">klen:</span> The length of the key.</p><p><span class="bold">Returns:</span> OL_SUCCESS when it succeeds, OL_FAILURE when it doesn't.</p><h3 class="perma" id="ol_uptime">ol_uptime <a href="#ol_uptime">&para;</a></h3><pre><code>int ol_uptime(ol_database *db);
</code></pre><p>Gets the time, in seconds, that a database has been up.</p><p><span class="bold">*db:</span> Database to retrieve value from.</p><p><span class="bold">Returns:</span> Uptime in seconds since database initialization.</p><h3 class="perma" id="ol_spoil">ol_spoil <a href="#ol_spoil">&para;</a></h3><pre><code>int ol_spoil(ol_database *db, const char *key, size_t klen, struct tm *expiration_date);
</code></pre><p>Sets the expiration value of a key. Will fail if no <a href="#ol_bucket">ol_bucket</a> under the chosen key exists.</p><p><span class="bold">*db:</span> Database to set the value to.</p><p><span class="bold">*key:</span> The key to use.</p><p><span class="bold">klen:</span> The length of the key.</p><p><span class="bold">expiration_date:</span> The <b>UTC</b> time to set the expiration to.</p><p><span class="bold">Returns:</span> OL_SUCCESS upon success, OL_FAILURE if otherwise.</p><h3 class="perma" id="ol_ht_bucket_max">ol_ht_bucket_max <a href="#ol_ht_bucket_max">&para;</a></h3><pre><code>unsigned int ol_ht_bucket_max(size_t ht_size);
</code></pre><p>Does some <code>sizeof</code> witchery to return the maximum current size of the database. This is mostly an internal function, exposed to reduce code duplication.</p><p><span class="bold">*ht_size:</span> The size you want to divide by <code>sizeof(ol_bucket)</code>.</p><p><span class="bold">Returns:</span> The maximum possible bucket slots for db.</p><h3 class="perma" id="ol_prefix_match">ol_prefix_match <a href="#ol_prefix_match">&para;</a></h3><pre><code>int ol_prefix_match(ol_database *db, const char *prefix, size_t plen, ol_key_array *data);
</code></pre><p>Returns values of keys that match a given prefix.</p><p><span class="bold">*db:</span> Database to retrieve values from.</p><p><span class="bold">*prefix:</span> The prefix to attempt matches on.</p><p><span class="bold">plen:</span> The length of the prefix.</p><p><span class="bold">*data:</span> A pointer to an <code>ol_key_array</code> object where the list of matching keys will be stored. <strong>Both the list and it's items must be freed after use.</strong></p><p><span class="bold">Returns:</span> -1 on failure, otherwise a positive integer representing the number of matched prefices in the database.</p><h3 class="perma" id="ol_key_dump">ol_key_dump <a href="#ol_key_dump">&para;</a></h3><pre><code>int ol_key_dump(ol_database *db, ol_key_array *data);
</code></pre><p>Like ol_prefix_match, except that it takes no prefix and just dumps the entire tree.</p><p><span class="bold">*db:</span> Database to retrieve values from.</p><p><span class="bold">*data:</span> A pointer to an <code>ol_key_array</code> object where the list of keys will be stored. <strong>Both the list and it's items must be freed after use.</strong></p><p><span class="bold">Returns:</span> -1 on failure, otherwise a positive integer representing the number of keys in the database on success.</p><h3 class="perma" id="ol_exists">ol_exists <a href="#ol_exists">&para;</a></h3><pre><code>int ol_exists(ol_database *db, const char *key, size_t klen);
</code></pre><p>Returns whether the given key exists on the database</p><p><span class="bold">*db:</span> Database the key should be in.</p><p><span class="bold">*key:</span> The key to check.</p><p><span class="bold">klen:</span> The length of the key.</p><p><span class="bold">Returns:</span> OL_SUCCESS if the key exists, OL_FAILURE otherwise.</p><h3 class="perma" id="ol_get_bucket">ol_get_bucket <a href="#ol_get_bucket">&para;</a></h3><pre><code>ol_bucket *ol_get_bucket(const ol_database *db, const char *key, const size_t klen,
                         char (*_key)[KEY_SIZE], size_t *_klen);
</code></pre><p>Utility function to retrieve an <a href="#ol_bucket">ol_bucket</a> object from the database for a given key.</p><p><span class="bold">*db:</span> Database the bucket should be in.</p><p><span class="bold">*key:</span> The key to check.</p><p><span class="bold">klen:</span> The length of the key.</p><p><span class="bold">**_key:</span> The truncated key will be filled in at this address.</p><p><span class="bold">*_klen:</span> The length of the truncated key.</p><p><span class="bold">Returns:</span> The bucket if it exists, otherwise NULL.</p><h3 class="perma" id="ol_squish">ol_squish <a href="#ol_squish">&para;</a></h3><pre><code>int ol_squish(ol_database *db);
</code></pre><p>Compacts both the aol file (if enabled) and the values file. This is a blocking operation.</p><p><span class="bold">*db:</span> The database to compact.</p><p><span class="bold">Returns:</span> OL_SUCCESS if successful, OL_FAILURE if otherwise.</p><h3 class="perma" id="ol_cas">ol_cas <a href="#ol_cas">&para;</a></h3><pre><code>int ol_cas(ol_database *db, const char *key, const size_t klen,
                            unsigned char *value, size_t vsize,
                            const unsigned char *ovalue, const size_t ovsize);
</code></pre><p>ol_jar operation that atomically compares-and-swaps old data for new data.</p><p><span class="bold">*db:</span> The database to operate on.</p><p><span class="bold">*key:</span> The key to check.</p><p><span class="bold">klen:</span> The length of the key.</p><p><span class="bold">*value:</span> The value to insert.</p><p><span class="bold">vsize:</span> The size of the value in bytes.</p><p><span class="bold">*ovalue:</span> The old value to compare against.</p><p><span class="bold">ovsize:</span> The size of the old value in bytes.</p><p><span class="bold">Returns:</span> OL_SUCCESS on success, OL_FAILURE otherwise.</p><h3 class="perma" id="ol_bulk_unjar">ol_bulk_unjar <a href="#ol_bulk_unjar">&para;</a></h3><pre><code>struct vector *ol_bulk_unjar(ol_database *db, const ol_key_array keys, const size_t num_keys);
</code></pre><p>Bulk unjar operation.</p><p><span class="bold">*db:</span> The database to unjar from.</p><p><span class="bold">*keys:</span> An <code>ol_key_array</code> of keys to unjar.</p><p><span class="bold">num_keys:</span> The number of keys in <code>*keys</code>.</p><p><span class="bold">Returns:</span> An immutable <code>vector</code> of pointers to matched values. The vector must be freed using <code>vector_free</code>, in addition to it's values with <code>free</code>.</p><h3 class="perma" id="ol_last_error">ol_last_error <a href="#ol_last_error">&para;</a></h3><pre><code>const char *ol_last_error(const ol_database *db);
</code></pre><p>Turns error codes on the database object into human readable strings.</p><p><span class="bold">*db:</span> The database to check.</p><p><span class="bold">Returns:</span> Returns a human readable string representing the last error that happened to <code>*db.</code></p>            </div>
        </div>
    </div>


        </div>
        <div id="busted_pixel">
            <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAAA1BMVEUA/wA0XsCoAAAACklEQVR4nGNiAAAABgADNjd8qAAAAABJRU5ErkJggg==">
        </div>
        
    <footer>
        <div class="grid grid-pad">
            <div class="col-1-2">
                <div class="content">
                    <ul>
                        <li>&copy; Copyright 2014-2018, <a href="http://qpfiffer.com/">Quinlan Pfiffer</a>, <a href="http://kyte.io/">Kyle Terry</a></li>
                    </ul>
                </div>
            </div>
            <div class="col-1-2">
                <div class="pull-right content">
                    <ul>
                        <li><a href="http://www.redbubble.com/people/qpfiffer/works/11380090-olegdb-graphics">Merch</a></li>
                        <li><a href="/credits.html">Credits</a></li>
                        <li>Contact: <a href="mailto:shithouse@goatse.cx">shithouse@goatse.cx</a></li>
                    </ul>
                </div>
            </div>
        </div>
    </footer>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-30510579-4', 'auto');
        ga('send', 'pageview');
    </script>
    <script type="text/javascript" src="/static/js/prism.js"></script>


    </body>
</html>
